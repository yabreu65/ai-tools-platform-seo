/**
 * Generador de reportes Excel para Keyword Research Tool
 * Crea archivos Excel con múltiples hojas y análisis detallados
 */

import * as XLSX from 'xlsx';

interface ExcelReportData {
  title: string;
  generatedDate: string;
  generatedBy: string;
  summary: {
    totalKeywords: number;
    avgDifficulty: number;
    totalVolume: number;
    avgCpc: number;
    topOpportunities: number;
  };
  keywords: Array<{
    keyword: string;
    volume: number;
    difficulty: number;
    cpc: number;
    competition: number;
    intent: string;
    trend: 'rising' | 'falling' | 'stable';
    opportunity: 'high' | 'medium' | 'low';
    position?: number;
    url?: string;
    lastUpdated?: string;
  }>;
  clusters?: Array<{
    name: string;
    size: number;
    avgVolume: number;
    avgDifficulty: number;
    intent: string;
    keywords: string[];
    coherenceScore: number;
    opportunities: string[];
  }>;
  trends?: Array<{
    keyword: string;
    data: Array<{ date: string; volume: number; position?: number }>;
    forecast: { predicted: number; confidence: number };
    seasonality: string;
    volatility: number;
  }>;
  competitors?: Array<{
    domain: string;
    keywords: number;
    avgPosition: number;
    marketShare: number;
    topKeywords: string[];
    strengths: string[];
    weaknesses: string[];
  }>;
  serpAnalysis?: Array<{
    keyword: string;
    features: string[];
    organicResults: number;
    paidResults: number;
    difficulty: number;
    opportunities: string[];
  }>;
  recommendations: Array<{
    category: string;
    priority: 'high' | 'medium' | 'low';
    recommendation: string;
    impact: string;
    effort: string;
  }>;
}

interface ExcelOptions {
  includeCharts: boolean;
  includeFormatting: boolean;
  separateSheets: boolean;
  includeFormulas: boolean;
}

class ExcelReportGenerator {
  private workbook: XLSX.WorkBook;

  constructor() {
    this.workbook = XLSX.utils.book_new();
  }

  /**
   * Genera reporte Excel completo
   */
  generateReport(data: ExcelReportData, options: ExcelOptions = {
    includeCharts: false,
    includeFormatting: true,
    separateSheets: true,
    includeFormulas: true
  }): Blob {
    // Generar hoja de resumen
    this.generateSummarySheet(data, options);

    // Generar hoja de keywords
    this.generateKeywordsSheet(data.keywords, options);

    // Generar hoja de clusters (si disponible)
    if (data.clusters && data.clusters.length > 0) {
      this.generateClustersSheet(data.clusters, options);
    }

    // Generar hoja de tendencias (si disponible)
    if (data.trends && data.trends.length > 0) {
      this.generateTrendsSheet(data.trends, options);
    }

    // Generar hoja de competidores (si disponible)
    if (data.competitors && data.competitors.length > 0) {
      this.generateCompetitorsSheet(data.competitors, options);
    }

    // Generar hoja de análisis SERP (si disponible)
    if (data.serpAnalysis && data.serpAnalysis.length > 0) {
      this.generateSerpAnalysisSheet(data.serpAnalysis, options);
    }

    // Generar hoja de recomendaciones
    this.generateRecommendationsSheet(data.recommendations, options);

    // Generar hoja de análisis avanzado
    if (options.includeFormulas) {
      this.generateAnalysisSheet(data, options);
    }

    // Convertir a blob
    const excelBuffer = XLSX.write(this.workbook, { 
      bookType: 'xlsx', 
      type: 'array',
      cellStyles: options.includeFormatting
    });

    return new Blob([excelBuffer], { 
      type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' 
    });
  }

  /**
   * Genera hoja de resumen
   */
  private generateSummarySheet(data: ExcelReportData, options: ExcelOptions): void {
    const summaryData = [
      ['Keyword Research Report Summary'],
      [''],
      ['Report Information'],
      ['Title', data.title],
      ['Generated Date', data.generatedDate],
      ['Generated By', data.generatedBy],
      [''],
      ['Key Metrics'],
      ['Total Keywords', data.summary.totalKeywords],
      ['Average Difficulty', data.summary.avgDifficulty],
      ['Total Search Volume', data.summary.totalVolume],
      ['Average CPC', `$${data.summary.avgCpc.toFixed(2)}`],
      ['High Opportunity Keywords', data.summary.topOpportunities],
      [''],
      ['Distribution Analysis'],
      ['Intent Distribution'],
      ...this.calculateIntentDistribution(data.keywords),
      [''],
      ['Difficulty Distribution'],
      ...this.calculateDifficultyDistribution(data.keywords),
      [''],
      ['Volume Distribution'],
      ...this.calculateVolumeDistribution(data.keywords),
      [''],
      ['Top Opportunities'],
      ['Keyword', 'Volume', 'Difficulty', 'CPC', 'Intent', 'Opportunity Score'],
      ...this.getTopOpportunities(data.keywords, 10)
    ];

    const worksheet = XLSX.utils.aoa_to_sheet(summaryData);

    // Aplicar formato si está habilitado
    if (options.includeFormatting) {
      this.applySummaryFormatting(worksheet);
    }

    XLSX.utils.book_append_sheet(this.workbook, worksheet, 'Summary');
  }

  /**
   * Genera hoja de keywords
   */
  private generateKeywordsSheet(keywords: any[], options: ExcelOptions): void {
    const headers = [
      'Keyword',
      'Search Volume',
      'Difficulty Score',
      'CPC',
      'Competition',
      'Intent',
      'Trend',
      'Opportunity Level',
      'Current Position',
      'URL',
      'Last Updated'
    ];

    const keywordData = keywords.map(k => [
      k.keyword,
      k.volume,
      k.difficulty,
      k.cpc,
      k.competition,
      k.intent,
      k.trend,
      k.opportunity,
      k.position || '',
      k.url || '',
      k.lastUpdated || ''
    ]);

    const worksheetData = [headers, ...keywordData];
    const worksheet = XLSX.utils.aoa_to_sheet(worksheetData);

    // Añadir fórmulas si está habilitado
    if (options.includeFormulas) {
      this.addKeywordFormulas(worksheet, keywords.length);
    }

    // Aplicar formato
    if (options.includeFormatting) {
      this.applyKeywordFormatting(worksheet, keywords.length);
    }

    XLSX.utils.book_append_sheet(this.workbook, worksheet, 'Keywords');
  }

  /**
   * Genera hoja de clusters
   */
  private generateClustersSheet(clusters: any[], options: ExcelOptions): void {
    // Hoja principal de clusters
    const clusterHeaders = [
      'Cluster Name',
      'Size',
      'Average Volume',
      'Average Difficulty',
      'Intent',
      'Coherence Score',
      'Top Keywords',
      'Opportunities'
    ];

    const clusterData = clusters.map(c => [
      c.name,
      c.size,
      c.avgVolume,
      c.avgDifficulty,
      c.intent,
      c.coherenceScore,
      c.keywords.slice(0, 5).join(', '),
      c.opportunities.join('; ')
    ]);

    const clusterWorksheetData = [clusterHeaders, ...clusterData];
    const clusterWorksheet = XLSX.utils.aoa_to_sheet(clusterWorksheetData);

    if (options.includeFormatting) {
      this.applyClusterFormatting(clusterWorksheet, clusters.length);
    }

    XLSX.utils.book_append_sheet(this.workbook, clusterWorksheet, 'Clusters');

    // Hoja detallada de keywords por cluster
    const detailedData = [['Cluster', 'Keyword', 'Volume', 'Difficulty', 'CPC', 'Intent']];
    
    clusters.forEach(cluster => {
      cluster.keywords.forEach((keyword: string) => {
        detailedData.push([
          cluster.name,
          keyword,
          '', // Se llenaría con datos reales
          '',
          '',
          cluster.intent
        ]);
      });
    });

    const detailedWorksheet = XLSX.utils.aoa_to_sheet(detailedData);
    XLSX.utils.book_append_sheet(this.workbook, detailedWorksheet, 'Cluster Details');
  }

  /**
   * Genera hoja de tendencias
   */
  private generateTrendsSheet(trends: any[], options: ExcelOptions): void {
    // Hoja de resumen de tendencias
    const trendHeaders = [
      'Keyword',
      'Data Points',
      'Current Volume',
      'Forecast',
      'Confidence',
      'Seasonality',
      'Volatility',
      'Trend Direction'
    ];

    const trendData = trends.map(t => [
      t.keyword,
      t.data.length,
      t.data[t.data.length - 1]?.volume || 0,
      t.forecast.predicted,
      `${(t.forecast.confidence * 100).toFixed(1)}%`,
      t.seasonality,
      t.volatility.toFixed(2),
      this.calculateTrendDirection(t.data)
    ]);

    const trendWorksheetData = [trendHeaders, ...trendData];
    const trendWorksheet = XLSX.utils.aoa_to_sheet(trendWorksheetData);

    if (options.includeFormatting) {
      this.applyTrendFormatting(trendWorksheet, trends.length);
    }

    XLSX.utils.book_append_sheet(this.workbook, trendWorksheet, 'Trends');

    // Hoja de datos históricos detallados
    const historicalData = [['Keyword', 'Date', 'Volume', 'Position']];
    
    trends.forEach(trend => {
      trend.data.forEach((point: any) => {
        historicalData.push([
          trend.keyword,
          point.date,
          point.volume,
          point.position || ''
        ]);
      });
    });

    const historicalWorksheet = XLSX.utils.aoa_to_sheet(historicalData);
    XLSX.utils.book_append_sheet(this.workbook, historicalWorksheet, 'Historical Data');
  }

  /**
   * Genera hoja de competidores
   */
  private generateCompetitorsSheet(competitors: any[], options: ExcelOptions): void {
    const competitorHeaders = [
      'Domain',
      'Total Keywords',
      'Average Position',
      'Market Share',
      'Top Keywords',
      'Strengths',
      'Weaknesses'
    ];

    const competitorData = competitors.map(c => [
      c.domain,
      c.keywords,
      c.avgPosition.toFixed(1),
      `${(c.marketShare * 100).toFixed(1)}%`,
      c.topKeywords?.join(', ') || '',
      c.strengths?.join('; ') || '',
      c.weaknesses?.join('; ') || ''
    ]);

    const competitorWorksheetData = [competitorHeaders, ...competitorData];
    const competitorWorksheet = XLSX.utils.aoa_to_sheet(competitorWorksheetData);

    if (options.includeFormatting) {
      this.applyCompetitorFormatting(competitorWorksheet, competitors.length);
    }

    XLSX.utils.book_append_sheet(this.workbook, competitorWorksheet, 'Competitors');
  }

  /**
   * Genera hoja de análisis SERP
   */
  private generateSerpAnalysisSheet(serpAnalysis: any[], options: ExcelOptions): void {
    const serpHeaders = [
      'Keyword',
      'SERP Features',
      'Organic Results',
      'Paid Results',
      'SERP Difficulty',
      'Opportunities'
    ];

    const serpData = serpAnalysis.map(s => [
      s.keyword,
      s.features.join(', '),
      s.organicResults,
      s.paidResults,
      s.difficulty,
      s.opportunities.join('; ')
    ]);

    const serpWorksheetData = [serpHeaders, ...serpData];
    const serpWorksheet = XLSX.utils.aoa_to_sheet(serpWorksheetData);

    if (options.includeFormatting) {
      this.applySerpFormatting(serpWorksheet, serpAnalysis.length);
    }

    XLSX.utils.book_append_sheet(this.workbook, serpWorksheet, 'SERP Analysis');
  }

  /**
   * Genera hoja de recomendaciones
   */
  private generateRecommendationsSheet(recommendations: any[], options: ExcelOptions): void {
    const recHeaders = [
      'Category',
      'Priority',
      'Recommendation',
      'Expected Impact',
      'Required Effort',
      'Status'
    ];

    const recData = recommendations.map(r => [
      r.category,
      r.priority,
      r.recommendation,
      r.impact,
      r.effort,
      'Pending'
    ]);

    const recWorksheetData = [recHeaders, ...recData];
    const recWorksheet = XLSX.utils.aoa_to_sheet(recWorksheetData);

    if (options.includeFormatting) {
      this.applyRecommendationFormatting(recWorksheet, recommendations.length);
    }

    XLSX.utils.book_append_sheet(this.workbook, recWorksheet, 'Recommendations');
  }

  /**
   * Genera hoja de análisis avanzado con fórmulas
   */
  private generateAnalysisSheet(data: ExcelReportData, options: ExcelOptions): void {
    const analysisData = [
      ['Advanced Analysis Dashboard'],
      [''],
      ['Calculated Metrics'],
      ['Total Potential Traffic', `=SUM(Keywords!B:B)`],
      ['Average Difficulty', `=AVERAGE(Keywords!C:C)`],
      ['Weighted Opportunity Score', `=SUMPRODUCT(Keywords!B:B,Keywords!C:C)/SUM(Keywords!B:B)`],
      ['High Volume Keywords (>10k)', `=COUNTIF(Keywords!B:B,">10000")`],
      ['Low Competition Keywords (<0.5)', `=COUNTIF(Keywords!E:E,"<0.5")`],
      [''],
      ['ROI Analysis'],
      ['Estimated Monthly Clicks', `=SUM(Keywords!B:B)*0.02`], // Asumiendo 2% CTR
      ['Estimated Monthly Cost', `=SUM(Keywords!D:D)*SUM(Keywords!B:B)*0.02`],
      ['Cost per Acquisition (estimated)', `=SUM(Keywords!D:D)*50`], // Asumiendo 50 clicks por conversión
      [''],
      ['Opportunity Matrix'],
      ['High Volume, Low Difficulty', `=COUNTIFS(Keywords!B:B,">5000",Keywords!C:C,"<30")`],
      ['Medium Volume, Low Difficulty', `=COUNTIFS(Keywords!B:B,">1000",Keywords!B:B,"<5000",Keywords!C:C,"<30")`],
      ['High Volume, High Difficulty', `=COUNTIFS(Keywords!B:B,">5000",Keywords!C:C,">70")`],
      [''],
      ['Intent Distribution'],
      ['Commercial Keywords', `=COUNTIF(Keywords!F:F,"commercial")`],
      ['Informational Keywords', `=COUNTIF(Keywords!F:F,"informational")`],
      ['Navigational Keywords', `=COUNTIF(Keywords!F:F,"navigational")`],
      ['Transactional Keywords', `=COUNTIF(Keywords!F:F,"transactional")`]
    ];

    const analysisWorksheet = XLSX.utils.aoa_to_sheet(analysisData);

    if (options.includeFormatting) {
      this.applyAnalysisFormatting(analysisWorksheet);
    }

    XLSX.utils.book_append_sheet(this.workbook, analysisWorksheet, 'Analysis');
  }

  /**
   * Aplica formato a la hoja de resumen
   */
  private applySummaryFormatting(worksheet: XLSX.WorkSheet): void {
    // Título principal
    if (!worksheet['!merges']) worksheet['!merges'] = [];
    worksheet['!merges'].push({ s: { r: 0, c: 0 }, e: { r: 0, c: 5 } });

    // Anchos de columna
    worksheet['!cols'] = [
      { width: 25 },
      { width: 20 },
      { width: 15 },
      { width: 15 },
      { width: 15 },
      { width: 15 }
    ];
  }

  /**
   * Aplica formato a la hoja de keywords
   */
  private applyKeywordFormatting(worksheet: XLSX.WorkSheet, rowCount: number): void {
    // Anchos de columna
    worksheet['!cols'] = [
      { width: 30 }, // Keyword
      { width: 15 }, // Volume
      { width: 12 }, // Difficulty
      { width: 10 }, // CPC
      { width: 12 }, // Competition
      { width: 15 }, // Intent
      { width: 10 }, // Trend
      { width: 15 }, // Opportunity
      { width: 12 }, // Position
      { width: 40 }, // URL
      { width: 15 }  // Last Updated
    ];

    // Formato condicional para dificultad
    this.addConditionalFormatting(worksheet, 'C', rowCount, 'difficulty');
    
    // Formato condicional para volumen
    this.addConditionalFormatting(worksheet, 'B', rowCount, 'volume');
  }

  /**
   * Aplica formato a la hoja de clusters
   */
  private applyClusterFormatting(worksheet: XLSX.WorkSheet, rowCount: number): void {
    worksheet['!cols'] = [
      { width: 25 }, // Cluster Name
      { width: 10 }, // Size
      { width: 15 }, // Avg Volume
      { width: 15 }, // Avg Difficulty
      { width: 15 }, // Intent
      { width: 15 }, // Coherence
      { width: 40 }, // Top Keywords
      { width: 50 }  // Opportunities
    ];
  }

  /**
   * Aplica formato a la hoja de tendencias
   */
  private applyTrendFormatting(worksheet: XLSX.WorkSheet, rowCount: number): void {
    worksheet['!cols'] = [
      { width: 25 }, // Keyword
      { width: 12 }, // Data Points
      { width: 15 }, // Current Volume
      { width: 15 }, // Forecast
      { width: 12 }, // Confidence
      { width: 15 }, // Seasonality
      { width: 12 }, // Volatility
      { width: 15 }  // Trend Direction
    ];
  }

  /**
   * Aplica formato a la hoja de competidores
   */
  private applyCompetitorFormatting(worksheet: XLSX.WorkSheet, rowCount: number): void {
    worksheet['!cols'] = [
      { width: 25 }, // Domain
      { width: 15 }, // Keywords
      { width: 15 }, // Avg Position
      { width: 15 }, // Market Share
      { width: 40 }, // Top Keywords
      { width: 40 }, // Strengths
      { width: 40 }  // Weaknesses
    ];
  }

  /**
   * Aplica formato a la hoja de SERP
   */
  private applySerpFormatting(worksheet: XLSX.WorkSheet, rowCount: number): void {
    worksheet['!cols'] = [
      { width: 25 }, // Keyword
      { width: 30 }, // Features
      { width: 15 }, // Organic Results
      { width: 15 }, // Paid Results
      { width: 15 }, // Difficulty
      { width: 50 }  // Opportunities
    ];
  }

  /**
   * Aplica formato a la hoja de recomendaciones
   */
  private applyRecommendationFormatting(worksheet: XLSX.WorkSheet, rowCount: number): void {
    worksheet['!cols'] = [
      { width: 20 }, // Category
      { width: 12 }, // Priority
      { width: 60 }, // Recommendation
      { width: 20 }, // Impact
      { width: 15 }, // Effort
      { width: 12 }  // Status
    ];
  }

  /**
   * Aplica formato a la hoja de análisis
   */
  private applyAnalysisFormatting(worksheet: XLSX.WorkSheet): void {
    worksheet['!cols'] = [
      { width: 35 },
      { width: 20 }
    ];
  }

  /**
   * Añade fórmulas a la hoja de keywords
   */
  private addKeywordFormulas(worksheet: XLSX.WorkSheet, rowCount: number): void {
    // Añadir columnas calculadas
    const lastCol = 'L'; // Después de la última columna de datos
    
    // Opportunity Score calculado
    worksheet[`${lastCol}1`] = { v: 'Opportunity Score', t: 's' };
    
    for (let i = 2; i <= rowCount + 1; i++) {
      // Fórmula: (Volume / 1000) * (100 - Difficulty) / 100
      worksheet[`${lastCol}${i}`] = { 
        f: `=(B${i}/1000)*(100-C${i})/100`, 
        t: 'n' 
      };
    }
  }

  /**
   * Añade formato condicional
   */
  private addConditionalFormatting(worksheet: XLSX.WorkSheet, column: string, rowCount: number, type: string): void {
    // Esta función sería más compleja en una implementación real
    // Por ahora, solo establecemos el rango para formato condicional
    const range = `${column}2:${column}${rowCount + 1}`;
    
    // En una implementación real, aquí se añadirían las reglas de formato condicional
    // usando las extensiones de XLSX o generando el XML apropiado
  }

  /**
   * Calcula distribución por intención
   */
  private calculateIntentDistribution(keywords: any[]): string[][] {
    const distribution = keywords.reduce((acc, keyword) => {
      acc[keyword.intent] = (acc[keyword.intent] || 0) + 1;
      return acc;
    }, {});

    return Object.entries(distribution).map(([intent, count]) => [
      intent.charAt(0).toUpperCase() + intent.slice(1),
      count.toString(),
      `${((count as number / keywords.length) * 100).toFixed(1)}%`
    ]);
  }

  /**
   * Calcula distribución por dificultad
   */
  private calculateDifficultyDistribution(keywords: any[]): string[][] {
    const ranges = {
      'Very Easy (0-19)': 0,
      'Easy (20-34)': 0,
      'Medium (35-49)': 0,
      'Hard (50-64)': 0,
      'Very Hard (65-79)': 0,
      'Extremely Hard (80-100)': 0
    };

    keywords.forEach(keyword => {
      if (keyword.difficulty < 20) ranges['Very Easy (0-19)']++;
      else if (keyword.difficulty < 35) ranges['Easy (20-34)']++;
      else if (keyword.difficulty < 50) ranges['Medium (35-49)']++;
      else if (keyword.difficulty < 65) ranges['Hard (50-64)']++;
      else if (keyword.difficulty < 80) ranges['Very Hard (65-79)']++;
      else ranges['Extremely Hard (80-100)']++;
    });

    return Object.entries(ranges).map(([range, count]) => [
      range,
      count.toString(),
      `${((count / keywords.length) * 100).toFixed(1)}%`
    ]);
  }

  /**
   * Calcula distribución por volumen
   */
  private calculateVolumeDistribution(keywords: any[]): string[][] {
    const ranges = {
      'Very Low (0-100)': 0,
      'Low (101-1,000)': 0,
      'Medium (1,001-10,000)': 0,
      'High (10,001-100,000)': 0,
      'Very High (100,000+)': 0
    };

    keywords.forEach(keyword => {
      if (keyword.volume <= 100) ranges['Very Low (0-100)']++;
      else if (keyword.volume <= 1000) ranges['Low (101-1,000)']++;
      else if (keyword.volume <= 10000) ranges['Medium (1,001-10,000)']++;
      else if (keyword.volume <= 100000) ranges['High (10,001-100,000)']++;
      else ranges['Very High (100,000+)']++;
    });

    return Object.entries(ranges).map(([range, count]) => [
      range,
      count.toString(),
      `${((count / keywords.length) * 100).toFixed(1)}%`
    ]);
  }

  /**
   * Obtiene las mejores oportunidades
   */
  private getTopOpportunities(keywords: any[], limit: number): string[][] {
    return keywords
      .filter(k => k.opportunity === 'high')
      .sort((a, b) => (b.volume / (b.difficulty + 1)) - (a.volume / (a.difficulty + 1)))
      .slice(0, limit)
      .map(k => [
        k.keyword,
        k.volume.toString(),
        k.difficulty.toString(),
        `$${k.cpc.toFixed(2)}`,
        k.intent,
        ((k.volume / (k.difficulty + 1)) / 100).toFixed(2)
      ]);
  }

  /**
   * Calcula dirección de tendencia
   */
  private calculateTrendDirection(data: any[]): string {
    if (data.length < 2) return 'Unknown';
    
    const recent = data.slice(-3).map(d => d.volume);
    const older = data.slice(-6, -3).map(d => d.volume);
    
    const recentAvg = recent.reduce((a, b) => a + b, 0) / recent.length;
    const olderAvg = older.reduce((a, b) => a + b, 0) / older.length;
    
    if (recentAvg > olderAvg * 1.1) return 'Rising';
    if (recentAvg < olderAvg * 0.9) return 'Falling';
    return 'Stable';
  }
}

export default ExcelReportGenerator;
export type { ExcelReportData, ExcelOptions };